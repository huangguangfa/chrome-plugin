/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/core/contentScript/network.js":
/*!*******************************************!*\
  !*** ./src/core/contentScript/network.js ***!
  \*******************************************/
/***/ (() => {

eval("const senMes = (data) =>{\r\n    window.postMessage(data, '*');\r\n}\r\n\r\nconst tool = {\r\n    isString(value) {\r\n        return Object.prototype.toString.call(value) == '[object String]';\r\n    },\r\n    isPlainObject(obj) {\r\n        let hasOwn = Object.prototype.hasOwnProperty;\r\n        // Must be an Object.\r\n        if (!obj || typeof obj !== 'object' || obj.nodeType || isWindow(obj)) {\r\n            return false;\r\n        }\r\n        try {\r\n            if (obj.constructor && !hasOwn.call(obj, 'constructor') && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {\r\n                return false;\r\n            }\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n        let key;\r\n        for (key in obj) {}\r\n        return key === undefined || hasOwn.call(obj, key);\r\n    }\r\n}\r\n\r\n//这个类是基于腾讯开源vconsole（https://github.com/Tencent/vConsole）、写的适用本插件的一个类\r\nclass RewriteNetwork {\r\n    constructor() {\r\n        this.reqList = {}; // URL as key, request item as value\r\n        this._open = undefined; // the origin function\r\n        this._send = undefined;\r\n        this._setRequestHeader = undefined;\r\n        this.status = false;\r\n        this.mockAjax();\r\n        this.mockFetch();\r\n    }\r\n    onRemove() {\r\n        if (window.XMLHttpRequest) {\r\n            window.XMLHttpRequest.prototype.open = this._open;\r\n            window.XMLHttpRequest.prototype.send = this._send;\r\n            window.XMLHttpRequest.prototype.setRequestHeader = this._setRequestHeader;\r\n            this._open = undefined;\r\n            this._send = undefined;\r\n            this._setRequestHeader = undefined\r\n        }\r\n    }\r\n  /**\r\n   * mock ajax request\r\n   * @private\r\n   */\r\n  mockAjax() {\r\n    let _XMLHttpRequest = window.XMLHttpRequest;\r\n    if (!_XMLHttpRequest) { return; }\r\n    const that = this;\r\n    //保存原生_XMLHttpRequest方法、用于下方重写\r\n    const _open = window.XMLHttpRequest.prototype.open,\r\n          _send = window.XMLHttpRequest.prototype.send,\r\n          _setRequestHeader = window.XMLHttpRequest.prototype.setRequestHeader;\r\n    that._open = _open;\r\n    that._send = _send;\r\n    that._setRequestHeader = _setRequestHeader;\r\n    //重写设置请求头open\r\n    window.XMLHttpRequest.prototype.open = function() {\r\n        let XMLReq = this;\r\n        let args = [].slice.call(arguments),\r\n            method = args[0],\r\n            url = args[1],\r\n            id = that.getUniqueID();\r\n        let timer = null;\r\n\r\n        // may be used by other functions\r\n        XMLReq._requestID = id;\r\n        XMLReq._method = method;\r\n        XMLReq._url = url;\r\n\r\n        // mock onreadystatechange\r\n        let _onreadystatechange = XMLReq.onreadystatechange || function() {};\r\n        //定时轮询去查看状态 每次 readyState 属性改变的时候调用的事件句柄函数。当 readyState 为 3 时，它也可能调用多次。\r\n        let onreadystatechange = function() {\r\n            let item = that.reqList[id] || {};\r\n\r\n            //恢复初始化\r\n            item.readyState = XMLReq.readyState;\r\n            item.status = 0;\r\n            //同步XMLReq状态\r\n            if (XMLReq.readyState > 1) {\r\n                item.status = XMLReq.status;\r\n            }\r\n            item.responseType = XMLReq.responseType;\r\n            //初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。\r\n            if (XMLReq.readyState == 0) {\r\n                if (!item.startTime) {\r\n                    item.startTime = (+new Date());\r\n                }\r\n                //open() 方法已调用，但是 send() 方法未调用。请求还没有被发送\r\n            } else if (XMLReq.readyState == 1) {\r\n                if (!item.startTime) {\r\n                    item.startTime = (+new Date());\r\n                }\r\n            //Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。\r\n            } else if (XMLReq.readyState == 2) {\r\n                // HEADERS_RECEIVED\r\n                item.header = {};\r\n                let header = XMLReq.getAllResponseHeaders() || '',\r\n                    headerArr = header.split(\"\\n\");\r\n                // extract plain text to key-value format\r\n                for (let i=0; i<headerArr.length; i++) {\r\n                    let line = headerArr[i];\r\n                    if (!line) { continue; }\r\n                    let arr = line.split(': ');\r\n                    let key = arr[0],\r\n                        value = arr.slice(1).join(': ');\r\n                    item.header[key] = value;\r\n                }\r\n            //所有响应头部都已经接收到。响应体开始接收但未完成\r\n            } else if (XMLReq.readyState == 3) {\r\n                 //HTTP 响应已经完全接收。\r\n            } else if (XMLReq.readyState == 4) {\r\n                clearInterval(timer);\r\n                item.endTime = +new Date(),\r\n                item.costTime = item.endTime - (item.startTime || item.endTime);\r\n                item.response = XMLReq.response;\r\n                item.method = XMLReq._method;\r\n                item.url = XMLReq._url;\r\n                item.req_type = 'xml';\r\n                item.getData = XMLReq.getData;\r\n                item.postData = XMLReq.postData;\r\n                that.filterData(item)\r\n            } else {\r\n                clearInterval(timer);\r\n            }\r\n        return _onreadystatechange.apply(XMLReq, arguments);\r\n      };\r\n      XMLReq.onreadystatechange = onreadystatechange;\r\n\r\n      //轮询查询状态\r\n      let preState = -1;\r\n      timer = setInterval(function() {\r\n        if (preState != XMLReq.readyState) {\r\n          preState = XMLReq.readyState;\r\n          onreadystatechange.call(XMLReq);\r\n        }\r\n      }, 10);\r\n\r\n      return _open.apply(XMLReq, args);\r\n    };\r\n\r\n    // 重写设置请求头setRequestHeader\r\n    window.XMLHttpRequest.prototype.setRequestHeader = function() {\r\n        const XMLReq = this;\r\n        const args = [].slice.call(arguments);\r\n\r\n        const item = that.reqList[XMLReq._requestID];\r\n        if (item) {\r\n            if (!item.requestHeader) { item.requestHeader = {}; }\r\n            item.requestHeader[args[0]] = args[1];\r\n        }\r\n        return _setRequestHeader.apply(XMLReq, args);\r\n    };\r\n\r\n    // 重写send\r\n    window.XMLHttpRequest.prototype.send = function() {\r\n        let XMLReq = this;\r\n        let args = [].slice.call(arguments),\r\n            data = args[0];\r\n\r\n        let item = that.reqList[XMLReq._requestID] || {};\r\n        item.method = XMLReq._method ? XMLReq._method.toUpperCase() : 'GET';\r\n\r\n        let query = XMLReq._url ? XMLReq._url.split('?') : []; // a.php?b=c&d=?e => ['a.php', 'b=c&d=', 'e']\r\n        item.url = XMLReq._url || '';\r\n        item.name = query.shift() || ''; // => ['b=c&d=', 'e']\r\n        item.name = item.name.replace(new RegExp('[/]*$'), '').split('/').pop() || '';\r\n        \r\n        if (query.length > 0) {\r\n            item.name += '?' + query;\r\n            item.getData = {};\r\n            query = query.join('?'); // => 'b=c&d=?e'\r\n            query = query.split('&'); // => ['b=c', 'd=?e']\r\n            for (let q of query) {\r\n            q = q.split('=');\r\n            item.getData[ q[0] ] = decodeURIComponent(q[1]);\r\n            }\r\n        }\r\n        if (item.method == 'POST') {\r\n            // save POST data\r\n            if (tool.isString(data)) {\r\n                let arr = data.split('&');\r\n                item.postData = {};\r\n                for (let q of arr) {\r\n                    q = q.split('=');\r\n                    item.postData[ q[0] ] = q[1];\r\n                }\r\n            } else if (tool.isPlainObject(data)) {\r\n                item.postData = data;\r\n            } else {\r\n                item.postData = '[object Object]';\r\n            }\r\n\r\n        }\r\n        XMLReq.getData = item.getData || \"\";\r\n        XMLReq.postData = item.postData || \"\";\r\n        return _send.apply(XMLReq, args);\r\n    };\r\n\r\n  };\r\n  \r\n  /**\r\n   * mock fetch request\r\n   * @private\r\n   */\r\n  mockFetch() {\r\n    const _fetch = window.fetch;\r\n    if (!_fetch) { return \"\"; }\r\n    const that = this;\r\n\r\n    const prevFetch = function(input, init){\r\n      let id = that.getUniqueID();\r\n      that.reqList[id] = {};\r\n      let item = that.reqList[id] || {};\r\n      let query = [],\r\n          url = '',\r\n          method = 'GET',\r\n          requestHeader = null;\r\n      // handle `input` content\r\n      if (tool.isString(input)) { // when `input` is a string\r\n        method = init.method ? init.method : 'GET';\r\n        url = input;\r\n        requestHeader = init.headers ? init.headers : null\r\n      } else { // when `input` is a `Request` object\r\n        method = input.method || 'GET';\r\n        url = input.url;\r\n        requestHeader = input.headers;\r\n      }\r\n      \r\n      query = url.split('?');\r\n\r\n      item.id = id;\r\n      item.method = method;\r\n      item.requestHeader = requestHeader;\r\n      item.url = url;\r\n      item.name = query.shift() || '';\r\n      item.name = item.name.replace(new RegExp('[/]*$'), '').split('/').pop() || '';\r\n\r\n      if (query.length > 0) {\r\n        item.name += '?' + query;\r\n        item.getData = {};\r\n        query = query.join('?'); // => 'b=c&d=?e'\r\n        query = query.split('&'); // => ['b=c', 'd=?e']\r\n        for (let q of query) {\r\n          q = q.split('=');\r\n          item.getData[ q[0] ] = q[1];\r\n        }\r\n      }\r\n      \r\n      if (item.method === \"post\") { \r\n        if (tool.isString(input)) {\r\n          if (tool.isString(init.body && init.body)) {\r\n            let arr = init.body.split('&');\r\n            item.postData = {};\r\n            for (let q of arr) {\r\n              q = q.split('=');\r\n              item.postData[ q[0] ] = q[1];\r\n            }\r\n          } else if (tool.isPlainObject(init.body && init.body)) {\r\n            item.postData = init.body && init.body;\r\n          } else {\r\n            item.postData = '[object Object]';\r\n          }\r\n        } else { // when `input` is a `Request` object\r\n          // cannot get real type of request's body, so just display \"[object Object]\"\r\n          item.postData = '[object Object]';\r\n        }\r\n      }\r\n    //   UNSENT\r\n        if (!item.startTime) {  item.startTime = (+new Date()); }\r\n        return _fetch(url, init).then((response) => {\r\n            response.clone().json().then((json) => {\r\n                item.endTime = +new Date(),\r\n                item.costTime = item.endTime - (item.startTime || item.endTime);\r\n                item.status = response.status;\r\n                item.header = {};\r\n                for (let pair of response.headers.entries()) {\r\n                    item.header[pair[0]] = pair[1];\r\n                }\r\n                item.response = json;\r\n                item.readyState = 4;\r\n                const contentType = response.headers.get('content-type');\r\n                item.responseType  = contentType.includes('application/json') ? 'json' : contentType.includes('text/html') ? 'text' : '';\r\n                item.req_type = 'fetch';\r\n                that.filterData(item)\r\n                return json;\r\n            })\r\n            return response;\r\n        })\r\n    }\r\n    window.fetch = prevFetch;\r\n  }\r\n  \r\n    filterData({ url,method,req_type,response,getData,postData}){\r\n        if(!url) return;\r\n        const req_data = {\r\n            url,\r\n            method,\r\n            req_type,\r\n            response,\r\n            getData, //query参数\r\n            postData\r\n        }\r\n        senMes(req_data)\r\n    }\r\n\r\n  /**\r\n   * generate an unique id string (32)\r\n   * @private\r\n   * @return string\r\n   */\r\n  getUniqueID() {\r\n    let id = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n        let r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\r\n        return v.toString(16);\r\n    });\r\n    return id;\r\n  }\r\n}\r\n\r\nconst network = new RewriteNetwork();\r\n\n\n//# sourceURL=webpack://chrome-plugin/./src/core/contentScript/network.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/core/contentScript/network.js"]();
/******/ 	
/******/ })()
;